// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: query.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const createBooking = `-- name: CreateBooking :exec
INSERT INTO booking
    (session_date, location, customer_id, session_package_id)
VALUES ($1, $2, $3, $4)
`

func (q *Queries) CreateBooking(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createBooking)
	return err
}

const createCustomer = `-- name: CreateCustomer :exec
INSERT INTO customer (first_name, last_name, email_address, mobile_number) VALUES ($1, $2, $3, $4)
`

func (q *Queries) CreateCustomer(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, createCustomer)
	return err
}

const getBookingByID = `-- name: GetBookingByID :one
SELECT
    b.booking_id,
    b.customer_id,
    b.session_package_id,
    b.session_date,
    b.location,
    b.created_at,
    c.first_name,
    c.last_name,
    c.email_address,
    st.session_type_id,
    st.name AS session_type,
    st.description,
    sp.name AS session_package,
    sp.duration_in_minutes,
    sp.price
FROM
    booking AS b
INNER JOIN
    customer AS c ON b.customer_id = c.customer_id
INNER JOIN
    session_package AS sp ON b.session_package_id = sp.session_package_id
INNER JOIN
    session_type AS st ON sp.session_type_id = st.session_type_id
WHERE
    booking_id=$1
`

type GetBookingByIDRow struct {
	BookingID         int32
	CustomerID        int32
	SessionPackageID  int32
	SessionDate       time.Time
	Location          sql.NullString
	CreatedAt         sql.NullTime
	FirstName         string
	LastName          sql.NullString
	EmailAddress      string
	SessionTypeID     int32
	SessionType       string
	Description       sql.NullString
	SessionPackage    string
	DurationInMinutes sql.NullInt32
	Price             int32
}

func (q *Queries) GetBookingByID(ctx context.Context) (GetBookingByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getBookingByID)
	var i GetBookingByIDRow
	err := row.Scan(
		&i.BookingID,
		&i.CustomerID,
		&i.SessionPackageID,
		&i.SessionDate,
		&i.Location,
		&i.CreatedAt,
		&i.FirstName,
		&i.LastName,
		&i.EmailAddress,
		&i.SessionTypeID,
		&i.SessionType,
		&i.Description,
		&i.SessionPackage,
		&i.DurationInMinutes,
		&i.Price,
	)
	return i, err
}

const getBookings = `-- name: GetBookings :many
SELECT
    b.booking_id,
    b.customer_id,
    b.session_package_id,
    b.session_date,
    b.location,
    b.created_at,
    c.first_name,
    c.last_name,
    c.email_address,
    st.session_type_id,
    st.name AS session_type,
    st.description,
    sp.name AS session_package,
    sp.duration_in_minutes,
    sp.price
FROM
    booking AS b
INNER JOIN
    customer AS c ON b.customer_id = c.customer_id
INNER JOIN
    session_package AS sp ON b.session_package_id = sp.session_package_id
INNER JOIN
    session_type AS st ON sp.session_type_id = st.session_type_id
LIMIT 50
`

type GetBookingsRow struct {
	BookingID         int32
	CustomerID        int32
	SessionPackageID  int32
	SessionDate       time.Time
	Location          sql.NullString
	CreatedAt         sql.NullTime
	FirstName         string
	LastName          sql.NullString
	EmailAddress      string
	SessionTypeID     int32
	SessionType       string
	Description       sql.NullString
	SessionPackage    string
	DurationInMinutes sql.NullInt32
	Price             int32
}

func (q *Queries) GetBookings(ctx context.Context) ([]GetBookingsRow, error) {
	rows, err := q.db.QueryContext(ctx, getBookings)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetBookingsRow
	for rows.Next() {
		var i GetBookingsRow
		if err := rows.Scan(
			&i.BookingID,
			&i.CustomerID,
			&i.SessionPackageID,
			&i.SessionDate,
			&i.Location,
			&i.CreatedAt,
			&i.FirstName,
			&i.LastName,
			&i.EmailAddress,
			&i.SessionTypeID,
			&i.SessionType,
			&i.Description,
			&i.SessionPackage,
			&i.DurationInMinutes,
			&i.Price,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCustomerByEmail = `-- name: GetCustomerByEmail :one
SELECT customer_id, first_name, last_name,email_address, mobile_number FROM customer
WHERE email_address=$1
LIMIT 1
`

type GetCustomerByEmailRow struct {
	CustomerID   int32
	FirstName    string
	LastName     sql.NullString
	EmailAddress string
	MobileNumber sql.NullString
}

func (q *Queries) GetCustomerByEmail(ctx context.Context) (GetCustomerByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, getCustomerByEmail)
	var i GetCustomerByEmailRow
	err := row.Scan(
		&i.CustomerID,
		&i.FirstName,
		&i.LastName,
		&i.EmailAddress,
		&i.MobileNumber,
	)
	return i, err
}

const getCustomerByID = `-- name: GetCustomerByID :one
SELECT customer_id, first_name, last_name,email_address, mobile_number FROM customer
WHERE customer_id=$1
LIMIT 1
`

type GetCustomerByIDRow struct {
	CustomerID   int32
	FirstName    string
	LastName     sql.NullString
	EmailAddress string
	MobileNumber sql.NullString
}

func (q *Queries) GetCustomerByID(ctx context.Context) (GetCustomerByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getCustomerByID)
	var i GetCustomerByIDRow
	err := row.Scan(
		&i.CustomerID,
		&i.FirstName,
		&i.LastName,
		&i.EmailAddress,
		&i.MobileNumber,
	)
	return i, err
}

const getCustomers = `-- name: GetCustomers :many
SELECT customer_id, first_name, last_name,email_address, mobile_number FROM customer LIMIT 100
`

type GetCustomersRow struct {
	CustomerID   int32
	FirstName    string
	LastName     sql.NullString
	EmailAddress string
	MobileNumber sql.NullString
}

func (q *Queries) GetCustomers(ctx context.Context) ([]GetCustomersRow, error) {
	rows, err := q.db.QueryContext(ctx, getCustomers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCustomersRow
	for rows.Next() {
		var i GetCustomersRow
		if err := rows.Scan(
			&i.CustomerID,
			&i.FirstName,
			&i.LastName,
			&i.EmailAddress,
			&i.MobileNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchCustomer = `-- name: SearchCustomer :many
SELECT customer_id, first_name, last_name,email_address, mobile_number FROM customer
WHERE first_name
ILIKE $1 OR last_name
ILIKE $1 LIMIT 5
`

type SearchCustomerRow struct {
	CustomerID   int32
	FirstName    string
	LastName     sql.NullString
	EmailAddress string
	MobileNumber sql.NullString
}

func (q *Queries) SearchCustomer(ctx context.Context) ([]SearchCustomerRow, error) {
	rows, err := q.db.QueryContext(ctx, searchCustomer)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchCustomerRow
	for rows.Next() {
		var i SearchCustomerRow
		if err := rows.Scan(
			&i.CustomerID,
			&i.FirstName,
			&i.LastName,
			&i.EmailAddress,
			&i.MobileNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
